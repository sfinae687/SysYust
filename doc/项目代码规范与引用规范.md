---
title: 项目代码规范与引用规范

---

# 项目代码规范与引用规范

项目使用ISO C++17（`clang++ --std=c++17 -O2 -lm`） 

可读性：任何维护代码的人都可以直接读出代码的意思，任何需要猜测阅读者猜测语义的写法都是损害可读性的。可读性不是能够一次性看到代码,是一次性能够看出代码的意思和结构.

## 项目文件结构

- 所有本项目的源代码放入 `src` 文件夹
- 模块公开的头文件放入 `include` 文件夹, 构建系统保证源文件能够以 `"header.h"` 的形式引用的头文件. 其余头文件与源文件一同放入 `src` 目录的子目录下.
- `test` 目录存放测试样例和驱动程序等测试相关源代码.
- `script` 目录放置一些 `git` 钩子脚本和其他用于保证项目的脚本. 但是项目相关内容的生成和构建以CMake作为入口.
- `lib` 目录存放第三方库,以git子模块的形式引入(条件允许的话.)
- 每个类都有独立的头文件/源文件. 只用于作为某个类的辅助类的类除外
- 对于主要由函数构成的文件, 请在文档注释中对文件描述来保证文档正常生成. 比如 `/**@file */`.

最终项目结构看起来像这样:

```txt
SysYust
|- lib/
|- include/
|     |- antlr4-target/  
|     `- xx.h
|- src/
|   |- frontend/
|   |    |- SysY.g4
|   |    `- antlr4-generated/
|   |- interpreter/
|   |- main.cpp
|   `- CMakeLists.txt
|- test/
|- doc/
|    |- generated/
|    `- xx.md
|- README.md
|- CMakeList.txt
|- Doxyfile
`- .gitignore
```


## 组件命名

- 类/结构体采取大驼峰命名法
- 函数采用小驼峰命名法
- 变量命名使用大驼峰命名法，单个单词的变量首字母小写，局部变量尽量不遮盖外层实体。
- 类的私有成员变量添加 `_` 前缀，然后首字母小写，避免与C++保留名冲突
- 抽象基类的命名应带有 `Base`, `Mixin`, `Interface` 等词汇表明其身份.

## 命名空间

- 本项目的所有实体，除 `main` 函数外，全部位于 `SysYust` 命名空间下
- 禁用 `using namespace` 指示，对于深层命名空间使用命名空间别名，对于常用名字使用 `using name`.
- 允许使用内联命名空间和匿名命名空间

## 语句与格式化

不要以为在没有自然语言的情况下你能重新读懂你的代码. 任何对代码注解和使代码便于分辨的的行为都不是激进的.

- 各种情况下,if,while,for等语句的子语句都使用复合语句,并适当格式化
- 不允许使用 `goto` 语句， 唯一的例外是从深层循环跳出
- 直落 `switch` 要标明 `[[fallthrough]]`
- 使用空行对逻辑进行分块, 必要的情况下使用注释注明.
- 缩进同一使用 4 空格,用于对齐时不限制.
- 行尾使用Unix风格(开启git的自动换行转换).
- 禁止行尾多余的空白.
- 不对格式化做出更多要求.

## 面向对象方法

- 鼓励使用设计模式,前提是良好的文档.
- 保持类的语义清晰,类所维护的不变式,拷贝控制所蕴含的语义,内存分配的要求,是否支持某些概念应在文档中说明清楚.
- 除了特殊的结构体语义的类，其他的所有的类都不应该有公开成员变量
- 保留 `union` 类的使用，但更优先考虑使用 `std::variant`.

## 模板

- 控制模板元编程的使用, 如果使用模板元,请详细注释

## RTTI与错误处理

- 保留异常的使用, 仅用于与外部组件交互
- 禁止异常外场景的 RTTI .
- 错误处理使用自建 `SysYust::expected` 和附加的错误处理组件
- 注意使用日志
- 发扬防御性编程的精神, **注意错误检查**.

## 内存管理

- 对于分配资源的类, 请清晰描述其拷贝语义, 并考虑接入分配器概念的支持
- 请优先考虑使用智能指针 `std::shared_ptr`, `std::unique_ptr`.

## 预处理器

- 预处理器只用于模块化和兼容性处理，禁止所有其他用途
- Header Guard格式，大写的 `SYSUEST_MODULE_FILE_H` 作为标识.
- 对于同一模块内部可以使用 `#prama once`, 但所有公开头必须使用 Header Guard.

## 文档,注释和标注

包括接口在内的程序解释性文档使用 Doxygen 注释写在源代码文件内.其余与程序版本密切相关的文档请放入 `doc` 子目录, 需要频繁修改的文档求放入本组共享文档中.

> Doxygen 注释简明示例
> 以下三种注释会被 Doxygen 识别
> ```cpp
> /// 单行风格
> //! 另一种
> 
> /*! Qt 风格
> */
> 
> /** Javadoc 风格
> */
> ```
> 将注释放在你需要注释的实体前, 使用 `<` 符号可以将注释放在需要注释的实体后.  
> ```Cpp
> int a; ///< a comment for variable a.
> ```
> 注释的段落可以时markdown格式的. 使用命令 `\brief` (或者也可以写作 `@brief`) 后面的一个段落,会被称为时实体的简介, `\details` 使后面的数个段落成为实体的具体描述
> ```Cpp
> /**
>  * @brief 一个获取随机值的函数  
> */
> std::size_t getRand();
> ```
> 使用 `\param` 描述函数的参数, 其中对变量的方向的指定(in, out)是可选的.  
> ```cpp
> /**
>  * @brief 交换两个整数
>  * @param[in,out] a,b 被交换的两个变量
> */
> void swap(int &a, int &b);
> ```
> 特殊的函数形参可以使用 `\tparam` 描述后接一个模板形参的名称和一个段落.  
> 对返回值的描述使用 `\return` 命令后接一个段落.  
> ```cpp
> /**
>  * @brief 获取xx的大小
>  * @tparam T 返回值的类型
>  * @return 一个数值,被转换为T所指定的类型.
> */
> template <typename T> //</typename T> 一个神奇的hackmd小问题
> T getSize();
> ```
> 命令 `\todo` 在源代码中标记一个待办事项.  
> [SEE ALSO](https://www.doxygen.nl/manual/commands.html)  

文件头部的Doxygen注释按照如下格式,暂时不在文件头部引入更多信息.  
    
> 文件头部的Doxygen
> ```cpp
> /// @file 文件描述
> /// 多行使用这种形式对齐. 在 `@file` 后直接换行
> ```

## 工作流

### 引用规范

延续git一贯的鼓励分支的风格,并合理运用github.

- 每个独立版本都具有单独的分支,比如可行性实验的版本 `preimpl`.
- 对于每个版本的每个 **大特性** 使用独立的分支进行开发,合适时并入对于的版本分支.在开发这些大特性的过程中可能还有用于修改的分支
- 较小的特性直接从版本分支分叉,完成后合并如版本分支.
- 切换分支工作时请注意更新 `README.md` 中的对分支描述的更新.

### 贡献流程

对于特性的贡献请fork存储库,并将你的fork的存储库clone到本地,创建分支进行修改,修改完成之后在github提交pullrequest,之后进行代码审计,然后合并.

合并之后你 github 的 fork 存储库可能需要与贮藏库同步.  